// SUICIDE.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
using namespace std;


//писала по гайдам, но понимаю, что происходит (мне так кажется, если честно)

//
//ЭТО СТРУКТУРА ДВУСВЯЗНОГО СПИСКА
//
struct Node
{
	int data;
	Node* prev, * next;
//это конструктор структуры (гайд сказал так надо, чтобы не морочить голову и автоматически инициализировать список))
public:
    Node(double data) {
        this->data = data;
        this->prev = this->next = NULL; 
    }
};

//
//ЭТО КЛАСС
//
class DoublyLinkedList
{
public:
	Node* head, * tail;

public:
    //конструктор класса
	DoublyLinkedList() {
        //инициализируем указатели списка, присваем им значение null, чтобы список был пустым
		this->head = this->tail = NULL;
	}
    //деструктор класса 
    ~DoublyLinkedList() {
        //удаляем все элементы списка, пока голова (первый эл) не будет пустой
        while (head != NULL)
            pop_front();
    }

    //
    //добавление в начало
    //
    Node* push_front(double data) {
        Node* ptr = new Node(data); //создаем новый узел так, чтобы элмент был доступен и после выхода

        ptr->next = head; //говорим, что СЛЕДУЮЩИЙ эл. после добавляемого - это голова (чтобы сохранить связи)
        if (head != NULL) //список не пуст?
            head->prev = ptr; //говорим, что ПЕРЕД головой теперь есть элемент (чтобы сохранить связи)
        if (tail == NULL) //а хвост пуст?
            tail = ptr; //да, тогда ставим первый элемент в список
        head = ptr; //новый элемент становится головой (ох уж эти карьерные лестницы)

        return ptr;
    }

    //
    //добавление в конец
    //
    Node* push_back(double data) {
        Node* ptr = new Node(data); //создаем новый узел так, чтобы элмент был доступен и после выхода

        ptr->prev = tail;  //говорим, что ПРЕДЫДУЩИЙ эл. после добавляемого - это хвост (чтобы сохранить связи)
        if (tail != NULL) //список пуст?
            tail->next = ptr; //говорим, что ПОСЛЕ хвоста теперь есть элемент (чтобы сохранить связи)
        if (head == NULL) //а голова пустая? (моя да)
            head = ptr; //да, тогда ставим первый элемент в список
        tail = ptr; //новый элемент становится хвостом (ох уж эти (не придумала))

        return ptr;
    }

    //
    //удаление в начале
    //
    void pop_front() {
        if (head == NULL) return; //голова пустая, список пустой - ничего не делаем

        Node* ptr = head->next; //сохраняем в указатель след. эл. после ткущей головы, так как он станет следующей головй после удаления
        if (ptr != NULL) //есть этот следующий элемент?
            ptr->prev = NULL; //да, тогда удаляем (оставляем пустым) то, что перед ним 
        else
            tail = NULL; //нет, ну и ладно, удалим то, что является хвостом

        delete head; //удаляем голову
        head = ptr; //зам стал главой
    }

    //
    //удаление в конце
    //
    void pop_back() {
        if (tail == NULL) return; //хвост пустой, список пустой - ничего не делаем

        Node* ptr = tail->prev; //сохраняем пред. эл. перед хвостом, потому что он станет следующим =)
        if (ptr != NULL) //есть этот предыдущий элемент?
            ptr->next = NULL; //да, тогда удаляем тот, что находится после него
        else
            head = NULL; //нет, тогда удаляем голову 

        delete tail; //удаляем хвост
        tail = ptr; //юмор кончился: предхвост стал хвостом
    }

    //
    //вывод списка
    //
    void display() {
        if (head == nullptr) { //пустой список - вывод шутки
            std::cout << "шутка дня:\nВ семье пулеметчиков умер сын.\nДля них это большая утрататата" << std::endl;
            return;
        }

        Node* current = head; //текущий эл. - голова
        while (current != nullptr) { //пока текущий эл. не пустой / конец списка
            std::cout << current->data << " "; //выводим тек. эл.
            current = current->next; //след. эл. становится текущим
        }
        std::cout << std::endl; //перевод на следующую строку
    }

    //
    //сортировка ПУЗЫРЬКОМ
    //
    void sort() {
        if (head == nullptr) return; //список пустой - ничего не делаем

        bool done; //чтобы проверить, что все элменты проверены и преставлены, как надо
        Node* curr; //текущий эл.
        Node* last = nullptr; //последний элемент, который уже отсортирован (пока пустой, соответсвенно, ничего же не делали)

        do {
            done = false; //для начала инициализируем, а потом, если внутр. цикл без обменов, то done остаётся false и мы выходим из цикла
            curr = head;//текущий элмент - голова списка

            while (curr->next != last) { //бегаем, пока след. эл. не станет последним отсортированным
                if (curr->data > curr->next->data) { //проверяем, что данные тек. эл. больше след. и тогда меняем местами

                    //меняем местами с помощью временной переменной
                    int time = curr->data;
                    curr->data = curr->next->data;
                    curr->next->data = time;

                    //всё поменяли молодцы, можно уходить
                    done = true;
                }
                curr = curr->next; //делаем след. эл. текущим 
            }
            last = curr; //последний отсортированнный стал текущим (чтобы не повторять проверку и пробег)
        } while (done); //бегаем пока у нас есть данные для сортировки

        return;
    }

    //
    //удаление дубликатов, сэр
    //
    void remove_duplicates() {
        if (head == nullptr) return; //список пустой - ничего не делаем

        Node* curr = head; //присваиваем текущему элементу голову списка

        while (curr != nullptr) { //пока текущий эл. не пустой / конец списка
            Node* sled = curr->next; //указатель, который является значением следующего элемента

            while (sled != nullptr) { //если не конец списка, то проверяем на ноличие клона -_-
                if (curr->data == sled->data) { //если текущий эл. равен следующему, то О УЖАС

                    Node* dupl = sled; //запомниаем указатель на дубликат (Большой босс следит за ним)
                    sled->prev->next = sled->next; //меняем указатель предыдущего элемента на следующий, чтобы при удалениии не было пустых (чего? ячеек?)
                    if (sled->next != nullptr) { //если не конец списка
                        sled->next->prev = sled->prev; //меняем указатель следующего элемента на предыдущий
                    }
                    sled = sled->next; //проверяем след. эл.
                    delete dupl; //удаляем дубликат
                }
                else {
                    sled = sled->next; //переход к след. узлу  для проверки наличия дубликата, если не найден дубль
                }
            }
            curr = curr->next; //переход к след. узлу, который будет проверяться на дубликат
        }
    }
};


int main()
{
    setlocale(LC_ALL, "Russian");

    DoublyLinkedList lst;
    int menu = 0;
    int val = NULL;
    int addsmthg = 0;

    do {
        cout << "Выбор действия: \n1. Добавить элемент в начало;\n2. Добавить элемент в конец;\n3. Удалить элемент в начале;\n4. Удалить элемент в конце;\n5. Отобразить список;\n6. Сортировать список;\n7. Удалить дубликаты;\n8. Выйти." << endl;
        cin >> menu;
        if (menu == 1)
        {
            cout << "Введите значение: ";
            cin >> val;
            lst.push_front(val);
        }
        else if (menu == 2)
        {
            cout << "Введите значение: ";
            cin >> val;
            lst.push_back(val);
        }
        else if (menu == 3)
        {
            lst.pop_front();
        }
        else if (menu == 4)
        {
            lst.pop_back();
        }
        else if (menu == 5)
        {
            lst.display();
        }
        else if (menu == 6)
        {
            lst.sort();
        }
        else if (menu == 7)
        {
            lst.remove_duplicates();
        }
        else if (menu == 8)
        {
            cout << "ДО СВИДАНИЯ!!!";
            break;
        }
        else cout << "Похоже вы выбрали что-то не то!" << endl;

    } while (menu != 8);

    //т.к. не используем динам. выд. памяти, то деструктор сработает автоматически


    
    //lst.push_back(2); //хвост
    //lst.push_back(23); //хвост
    //lst.push_front(23); //голова
    //lst.push_front(4); //голова
    //lst.push_front(11); //голова
    //lst.push_front(3); //голова 
    //lst.push_front(11); //голова
    //lst.push_back(11); //хвост

    //lst.display(); //вывод

    //lst.sort(); //сортируем

    //lst.display(); //выводим отсортированное

    //lst.remove_duplicates(); //удаляем дубликаты

    //lst.display(); //выводим 

    return 0;
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
